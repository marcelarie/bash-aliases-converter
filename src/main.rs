mod command;
mod config;
mod syntax_tree;

use command::arguments::CliArgs;
use config::alias_ignore::{self, AliasIgnoreResult};
use std::{
    collections::HashSet,
    fs::{self, File},
    io::{BufWriter, Write},
    path::Path,
};
use syntax_tree::find_aliases;
use tree_sitter::Parser;

fn main() {
    let args = CliArgs::new().unwrap_or_else(|e| {
        eprintln!("Error: {}", e);
        std::process::exit(1);
    });
    let file_exists = Path::new(&args.file_path).exists();

    if !file_exists {
        eprintln!("Error: File path {} does not exist", args.file_path);
        std::process::exit(1);
    }

    let alias_ignore_result =
        alias_ignore::get_ignore_set().unwrap_or_else(|| AliasIgnoreResult {
            alias_ignores: HashSet::new(),
            command_ignores: Vec::new(),
        });

    let code = fs::read_to_string(&args.file_path).expect("Error reading file");

    let mut parser = Parser::new();
    let language = tree_sitter_bash::LANGUAGE;

    parser
        .set_language(&language.into())
        .expect("Error loading Bash language");

    let tree = parser.parse(&code, None).expect("Error parsing code");

    let mut cursor = tree.walk();

    let aliases = find_aliases(&mut cursor, code.as_bytes());

    let output_file_path = "alias.nu";
    let file =
        File::create(&output_file_path).expect("Error creating output file");
    let mut writer = BufWriter::with_capacity(64 * 1024, file); // 64KB buffer

    writeln!(writer, "# Aliases auto generated by nu-alias-converter\n")
        .expect("Error writing to file");

    for alias in aliases {
        let command_ignores = &alias_ignore_result.command_ignores;

        let should_ignore_alias_name =
            alias_ignore_result.alias_ignores.contains(&alias.name);

        let matching_cmd = command_ignores
            .iter()
            .find(|cmd| alias.content.contains(*cmd));

        let should_ignore = should_ignore_alias_name || matching_cmd.is_some();

        if alias.is_valid_nushell && !should_ignore {
            writeln!(writer, "alias {} = {}", alias.name, alias.content)
                .expect("Error writing to file");
        } else if should_ignore && !args.no_comments {
            if let Some(matching_cmd) = matching_cmd {
                writeln!(
                writer,
                "# alias {} = {} # Ignored all alias using '{}' command via .aliasignore",
                alias.name, alias.content, matching_cmd
            )
            .expect("Error writing to file");
            } else {
                writeln!(
                    writer,
                    "# alias {} = {} # Ignored alias via .aliasignore",
                    alias.name, alias.content
                )
                .expect("Error writing to file");
            }
        } else if !args.no_comments {
            writeln!(
                writer,
                "# alias {} = {} # Errors: {}",
                alias.name,
                alias.content,
                alias.error_messages.join(", ")
            )
            .expect("Error writing to file");
        }
    }

    // writer.flush().expect("Error flushing the buffer");

    println!("Aliases written to {}", output_file_path);
}
